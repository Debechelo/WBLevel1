# Устные вопросы

### Вопрос 1

Какой самый эффективный способ конкатенации строк?

```
strings.Builder  
strings.Builder предоставляет методы для добавления строк к буферу 
без создания новых строк
```

### Вопрос 2.

Что такое интерфейсы, как они применяются в Go?

```
В Go интерфейсы представляют собой набор методов, определенных без их реализации.
Объект в Go автоматически считается реализующим интерфейс, если он предоставляет
реализацию всех методов, определенных в этом интерфейсе. Интерфейсы часто
используются в Go для создания гибкого кода, позволяя работать
с различными типами данных, поддерживающими одинаковое поведение (полиморфизм)
```

### Вопрос 3.

Чем отличаются RWMutex от Mutex?

```
Mutex предоставляет простой мьютекс, который может быть заблокирован (защищен)
только одной горутиной в определенный момент времени. Это обеспечивает
эксклюзивный доступ к общему ресурсу.

RWMutex (читаемо-записываемый мьютекс) предоставляет более сложный мьютекс,
который разделяет блокировку на два режима: чтение (когда множество
горутин может одновременно читать данные) и запись (когда только одна горутина
может записывать данные, и ни одна из горутин не может читать)
```

### Вопрос 4.

Чем отличаются буферизированные и не буферизированные каналы?

```

Не буферизированный канал: Синхронный обмен данными, блокируется
 при отправке или приеме.

Буферизированный канал: Асинхронный обмен данными, не 
блокируется, если буфер не заполнен или не пуст.
```

### Вопрос 5.

Какой размер у структуры `struct{}{}?`

```
Размер 0 байт


```

### Вопрос 6.

Есть ли в Go перегрузка методов или операторов?

```
Нет
```

### Вопрос 7.

В какой последовательности будут выведены элементы `map[int]int`?

Пример:

```
m[0]=1
m[1]=124
m[2]=281
```

```
Никому не известно
```

### Вопрос 8.

В чем разница make и new?

```
- make возвращает инициализированный тип, готовый к использованию
- new возвращает указатель на тип с его нулевым значением

```

### Вопрос 9.

Сколько существует способов задать переменную типа slice или map?

```

1. mySlice := []int{1, 2, 3}

2. mySlice := make([]int, 5, 10)

3. myMap := map[string]int{"a": 1, "b": 2, "c": 3}

4. myMap := make(map[string]int, 10) 
```

### Вопрос 10.

Что выведет данная программа и почему?

```
func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```

```
1
1

p является локальной для функции update и не влияет на значение p в функции main.
```

### Вопрос 11.

Что выведет данная программа и почему?

```
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```

```
После создания горутин в основной горутине вызывается wg.Wait(),
ожидая завершения всех горутин. Однако, из-за копирования WaitGroup и 
отсутствия синхронизации, программа может завершиться, прежде чем все 
горутины закончат выполнение. Таким образом, exit может быть выведено до 
завершения всех горутин.
```

### Вопрос 12.

Что выведет данная программа и почему?

```
func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
```

```
0 так как новое n в другой области видимости
```

### Вопрос 13.

Что выведет данная программа и почему?

```
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```

```
[100 2 3 4 5]
```

### Вопрос 14.

Что выведет данная программа и почему?

```
func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```

```
[b b a]
[a a]

append создает новый слайс
```

